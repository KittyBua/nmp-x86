reverted:
--- b/generic-pc/audio.cpp
+++ a/generic-pc/audio.cpp
@@ -54,8 +54,7 @@
 static ao_device *adevice = NULL;
 static ao_sample_format sformat;
 
+static AVCodecContext *c= NULL;
-static AVCodecContext *c = NULL;
-static AVCodecParameters *p = NULL;
 
 cAudio::cAudio(void *, void *, void *)
 {
@@ -357,31 +356,28 @@
 		lt_info("%s: nb_streams: %d, should be 1!\n", __func__, avfc->nb_streams);
 		goto out;
 	}
+	if (avfc->streams[0]->codec->codec_type != AVMEDIA_TYPE_AUDIO)
+		lt_info("%s: stream 0 no audio codec? 0x%x\n", __func__, avfc->streams[0]->codec->codec_type);
-	p = avfc->streams[0]->codecpar;
-	if (p->codec_type != AVMEDIA_TYPE_AUDIO)
-		lt_info("%s: stream 0 no audio codec? 0x%x\n", __func__, p->codec_type);
 
+	c = avfc->streams[0]->codec;
+	codec = avcodec_find_decoder(c->codec_id);
-	codec = avcodec_find_decoder(p->codec_id);
 	if (!codec) {
+		lt_info("%s: Codec for %s not found\n", __func__, avcodec_get_name(c->codec_id));
-		lt_info("%s: Codec for %s not found\n", __func__, avcodec_get_name(p->codec_id));
 		goto out;
 	}
-	if (c)
-		av_free(c);
-	c = avcodec_alloc_context3(codec);
 	if (avcodec_open2(c, codec, NULL) < 0) {
 		lt_info("%s: avcodec_open2() failed\n", __func__);
 		goto out;
 	}
 	frame = av_frame_alloc();
 	if (!frame) {
+		lt_info("%s: avcodec_alloc_frame failed\n", __func__);
-		lt_info("%s: av_frame_alloc failed\n", __func__);
 		goto out2;
 	}
 	/* output sample rate, channels, layout could be set here if necessary */
+	o_ch = c->channels;		/* 2 */
+	o_sr = c->sample_rate;		/* 48000 */
+	o_layout = c->channel_layout;	/* AV_CH_LAYOUT_STEREO */
-	o_ch = p->channels;		/* 2 */
-	o_sr = p->sample_rate;		/* 48000 */
-	o_layout = p->channel_layout;	/* AV_CH_LAYOUT_STEREO */
 	if (sformat.channels != o_ch || sformat.rate != o_sr ||
 	    sformat.byte_format != AO_FMT_NATIVE || sformat.bits != 16 || adevice == NULL)
 	{
@@ -396,9 +392,8 @@
 		adevice = ao_open_live(driver, &sformat, NULL);
 		ai = ao_driver_info(driver);
 		lt_info("%s: changed params ch %d srate %d bits %d adevice %p\n",
+			__func__, o_ch, o_sr, 16, adevice);;
+		lt_info("libao driver: %d name '%s' short '%s' author '%s'\n",
-			__func__, o_ch, o_sr, 16, adevice);
-		if(ai)
-			lt_info("libao driver: %d name '%s' short '%s' author '%s'\n",
 				driver, ai->name, ai->short_name, ai->author);
 	}
 #if 0
@@ -409,10 +404,10 @@
 #endif
 	av_get_sample_fmt_string(tmp, sizeof(tmp), c->sample_fmt);
 	lt_info("decoding %s, sample_fmt %d (%s) sample_rate %d channels %d\n",
+		 avcodec_get_name(c->codec_id), c->sample_fmt, tmp, c->sample_rate, c->channels);
-		 avcodec_get_name(p->codec_id), c->sample_fmt, tmp, p->sample_rate, p->channels);
 	swr = swr_alloc_set_opts(swr,
 				 o_layout, AV_SAMPLE_FMT_S16, o_sr,			/* output */
+				 c->channel_layout, c->sample_fmt, c->sample_rate,	/* input */
-				 p->channel_layout, c->sample_fmt, p->sample_rate,	/* input */
 				 0, NULL);
 	if (! swr) {
 		lt_info("could not alloc resample context\n");
@@ -426,15 +421,15 @@
 		avcodec_decode_audio4(c, frame, &gotframe, &avpkt);
 		if (gotframe && thread_started) {
 			int out_linesize;
+			obuf_sz = av_rescale_rnd(swr_get_delay(swr, c->sample_rate) +
+						 frame->nb_samples, o_sr, c->sample_rate, AV_ROUND_UP);
-			obuf_sz = av_rescale_rnd(swr_get_delay(swr, p->sample_rate) +
-						 frame->nb_samples, o_sr, p->sample_rate, AV_ROUND_UP);
 			if (obuf_sz > obuf_sz_max) {
 				lt_info("obuf_sz: %d old: %d\n", obuf_sz, obuf_sz_max);
 				av_free(obuf);
 				if (av_samples_alloc(&obuf, &out_linesize, o_ch,
 							frame->nb_samples, AV_SAMPLE_FMT_S16, 1) < 0) {
 					lt_info("av_samples_alloc failed\n");
+					av_free_packet(&avpkt);
-					av_packet_unref(&avpkt);
 					break; /* while (thread_started) */
 				}
 				obuf_sz_max = obuf_sz;
@@ -447,7 +442,7 @@
 								  obuf_sz, AV_SAMPLE_FMT_S16, 1);
 			ao_play(adevice, (char *)obuf, o_buf_sz);
 		}
+		av_free_packet(&avpkt);
-		av_packet_unref(&avpkt);
 	}
 	// ao_close(adevice); /* can take long :-( */
 	av_free(obuf);
@@ -456,7 +451,6 @@
 	av_frame_free(&frame);
  out2:
 	avcodec_close(c);
-	av_free(c);
 	c = NULL;
  out:
 	avformat_close_input(&avfc);
reverted:
--- b/generic-pc/video.cpp
+++ a/generic-pc/video.cpp
@@ -30,7 +30,6 @@
 
 extern "C" {
 #include <libavformat/avformat.h>
-#include <libavutil/imgutils.h>
 #include <libswscale/swscale.h>
 }
 
@@ -80,12 +79,10 @@
 	buf_in = 0;
 	buf_out = 0;
 	pig_x = pig_y = pig_w = pig_h = 0;
-	pig_changed = false;
 	display_aspect = DISPLAY_AR_16_9;
 	display_crop = DISPLAY_AR_MODE_LETTERBOX;
 	v_format = VIDEO_FORMAT_MPEG2;
 	output_h = 0;
-	stillpicture = false;
 }
 
 cVideo::~cVideo(void)
@@ -166,18 +163,6 @@
 	return 1;
 }
 
-int cVideo::GetVideoSystem()
-{
-	int current_video_system = VIDEO_STD_1080I50;
-
-	if(dec_w < 720)
-		current_video_system = VIDEO_STD_PAL;
-	else if(dec_w > 720 && dec_w <= 1280)
-		current_video_system = VIDEO_STD_720P50;
-
-	return current_video_system;
-}
-
 int cVideo::SetVideoSystem(int system, bool)
 {
 	int h;
@@ -211,13 +196,25 @@
 			lt_info("%s: unhandled value %d\n", __func__, system);
 			return 0;
 	}
+	v_std = (VIDEO_STD) system;
-//	v_std = (VIDEO_STD) system;
 	output_h = h;
 	if (display_aspect < DISPLAY_AR_RAW && output_h > 0) /* don't know what to do with this */
 		glfb->setOutputFormat(aspect_ratios[display_aspect], output_h, display_crop);
 	return 0;
 }
 
+int cVideo::GetVideoSystem()
+{
+	int current_video_system = VIDEO_STD_1080I50;
+
+	if(dec_w < 720)
+		current_video_system = VIDEO_STD_PAL;
+	else if(dec_w > 720 && dec_w <= 1280)
+		current_video_system = VIDEO_STD_720P50;
+
+	return 0;
+}
+
 int cVideo::getPlayState(void)
 {
 	return VIDEO_PLAYING;
@@ -227,17 +224,11 @@
 {
 }
 
+void cVideo::ShowPicture(const char *fname, const char *)
-void cVideo::ShowPicture(const char *fname)
 {
 	lt_info("%s(%s)\n", __func__, fname);
 	if (access(fname, R_OK))
 		return;
-	still_m.lock();
-	stillpicture = true;
-	buf_num = 0;
-	buf_in = 0;
-	buf_out = 0;
-	still_m.unlock();
 
 	unsigned int i;
 	int stream_id = -1;
@@ -245,7 +236,6 @@
 	int len;
 	AVFormatContext *avfc = NULL;
 	AVCodecContext *c = NULL;
-	AVCodecParameters *p = NULL;
 	AVCodec *codec;
 	AVFrame *frame, *rgbframe;
 	AVPacket avpkt;
@@ -260,18 +250,17 @@
 		goto out_close;
 	}
 	for (i = 0; i < avfc->nb_streams; i++) {
+		if (avfc->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
-		if (avfc->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
 			stream_id = i;
 			break;
 		}
 	}
 	if (stream_id < 0)
 		goto out_close;
+	c = avfc->streams[stream_id]->codec;
+	codec = avcodec_find_decoder(c->codec_id);
+	if (!avcodec_open2(c, codec, NULL) < 0) {
+		lt_info("%s: Could not find/open the codec, id 0x%x\n", __func__, c->codec_id);
-	p = avfc->streams[stream_id]->codecpar;
-	codec = avcodec_find_decoder(p->codec_id);
-	c = avcodec_alloc_context3(codec);
-	if (avcodec_open2(c, codec, NULL) < 0) {
-		lt_info("%s: Could not find/open the codec, id 0x%x\n", __func__, p->codec_id);
 		goto out_close;
 	}
 	frame = av_frame_alloc();
@@ -288,15 +277,15 @@
 	len = avcodec_decode_video2(c, frame, &got_frame, &avpkt);
 	if (len < 0) {
 		lt_info("%s: avcodec_decode_video2 %d\n", __func__, len);
+		av_free_packet(&avpkt);
-		av_packet_unref(&avpkt);
 		goto out_free;
 	}
 	if (avpkt.size > len)
 		lt_info("%s: WARN: pkt->size %d != len %d\n", __func__, avpkt.size, len);
 	if (got_frame) {
+		unsigned int need = avpicture_get_size(PIX_FMT_RGB32, c->width, c->height);
-		unsigned int need = av_image_get_buffer_size(AV_PIX_FMT_RGB32, c->width, c->height, 1);
 		struct SwsContext *convert = sws_getContext(c->width, c->height, c->pix_fmt,
+							    c->width, c->height, PIX_FMT_RGB32,
-							    c->width, c->height, AV_PIX_FMT_RGB32,
 							    SWS_BICUBIC, 0, 0, 0);
 		if (!convert)
 			lt_info("%s: ERROR setting up SWS context\n", __func__);
@@ -305,8 +294,8 @@
 			SWFramebuffer *f = &buffers[buf_in];
 			if (f->size() < need)
 				f->resize(need);
+			avpicture_fill((AVPicture *)rgbframe, &(*f)[0], PIX_FMT_RGB32,
+					c->width, c->height);
-			av_image_fill_arrays(rgbframe->data, rgbframe->linesize, &(*f)[0], AV_PIX_FMT_RGB32,
-					c->width, c->height, 1);
 			sws_scale(convert, frame->data, frame->linesize, 0, c->height,
 					rgbframe->data, rgbframe->linesize);
 			sws_freeContext(convert);
@@ -319,7 +308,7 @@
 			buf_in %= VDEC_MAXBUFS;
 			buf_num++;
 			if (buf_num > (VDEC_MAXBUFS - 1)) {
+				lt_debug("%s: buf_num overflow\n", __func__);
-				lt_info("%s: buf_num overflow\n", __func__);
 				buf_out++;
 				buf_out %= VDEC_MAXBUFS;
 				buf_num--;
@@ -327,10 +316,9 @@
 			buf_m.unlock();
 		}
 	}
+	av_free_packet(&avpkt);
-	av_packet_unref(&avpkt);
  out_free:
 	avcodec_close(c);
-	av_free(c);
 	av_frame_free(&frame);
 	av_frame_free(&rgbframe);
  out_close:
@@ -340,10 +328,6 @@
 
 void cVideo::StopPicture()
 {
-	lt_info("%s\n", __func__);
-	still_m.lock();
-	stillpicture = false;
-	still_m.unlock();
 }
 
 void cVideo::Standby(unsigned int)
@@ -367,32 +351,7 @@
 {
 	width = dec_w;
 	height = dec_h;
+	rate = dec_r;
-	switch (dec_r) {
-		case 23://23.976fps
-			rate = VIDEO_FRAME_RATE_23_976;
-			break;
-		case 24:
-			rate = VIDEO_FRAME_RATE_24;
-			break;
-		case 25:
-			rate = VIDEO_FRAME_RATE_25;
-			break;
-		case 29://29,976fps
-			rate = VIDEO_FRAME_RATE_29_97;
-			break;
-		case 30:
-			rate = VIDEO_FRAME_RATE_30;
-			break;
-		case 50:
-			rate = VIDEO_FRAME_RATE_50;
-			break;
-		case 60:
-			rate = VIDEO_FRAME_RATE_60;
-			break;
-		default:
-			rate = dec_r;
-			break;
-	}
 }
 
 void cVideo::SetSyncMode(AVSYNC_TYPE)
@@ -448,7 +407,6 @@
 {
 	lt_info("====================== start decoder thread ================================\n");
 	AVCodec *codec;
-	AVCodecParameters *p = NULL;
 	AVCodecContext *c= NULL;
 	AVFormatContext *avfc = NULL;
 	AVInputFormat *inp;
@@ -489,21 +447,20 @@
 		lt_info("%s: nb_streams %d, should be 1 => retry\n", __func__, avfc->nb_streams);
 		if (av_read_frame(avfc, &avpkt) < 0)
 			lt_info("%s: av_read_frame < 0\n", __func__);
+		av_free_packet(&avpkt);
-		av_packet_unref(&avpkt);
 		if (! thread_running)
 			goto out;
 	}
 
+	if (avfc->streams[0]->codec->codec_type != AVMEDIA_TYPE_VIDEO)
+		lt_info("%s: no video codec? 0x%x\n", __func__, avfc->streams[0]->codec->codec_type);
-	p = avfc->streams[0]->codecpar;
-	if (p->codec_type != AVMEDIA_TYPE_VIDEO)
-		lt_info("%s: no video codec? 0x%x\n", __func__, p->codec_type);
 
+	c = avfc->streams[0]->codec;
+	codec = avcodec_find_decoder(c->codec_id);
-	codec = avcodec_find_decoder(p->codec_id);
 	if (!codec) {
+		lt_info("%s: Codec for %s not found\n", __func__, avcodec_get_name(c->codec_id));
-		lt_info("%s: Codec for %s not found\n", __func__, avcodec_get_name(p->codec_id));
 		goto out;
 	}
-	c = avcodec_alloc_context3(codec);
 	if (avcodec_open2(c, codec, NULL) < 0) {
 		lt_info("%s: Could not open codec\n", __func__);
 		goto out;
@@ -531,17 +488,16 @@
 				lt_info("%s: avcodec_decode_video2 %d\n", __func__, len);
 				warn_d = time(NULL);
 			}
+			av_free_packet(&avpkt);
-			av_packet_unref(&avpkt);
 			continue;
 		}
 		if (avpkt.size > len)
 			lt_info("%s: WARN: pkt->size %d != len %d\n", __func__, avpkt.size, len);
+		if (got_frame) {
+			unsigned int need = avpicture_get_size(PIX_FMT_RGB32, c->width, c->height);
-		still_m.lock();
-		if (got_frame && ! stillpicture) {
-			unsigned int need = av_image_get_buffer_size(AV_PIX_FMT_RGB32, c->width, c->height, 1);
 			convert = sws_getCachedContext(convert,
 						       c->width, c->height, c->pix_fmt,
+						       c->width, c->height, PIX_FMT_RGB32,
-						       c->width, c->height, AV_PIX_FMT_RGB32,
 						       SWS_BICUBIC, 0, 0, 0);
 			if (!convert)
 				lt_info("%s: ERROR setting up SWS context\n", __func__);
@@ -550,8 +506,8 @@
 				SWFramebuffer *f = &buffers[buf_in];
 				if (f->size() < need)
 					f->resize(need);
+				avpicture_fill((AVPicture *)rgbframe, &(*f)[0], PIX_FMT_RGB32,
+						c->width, c->height);
-				av_image_fill_arrays(rgbframe->data, rgbframe->linesize, &(*f)[0], AV_PIX_FMT_RGB32,
-						c->width, c->height, 1);
 				sws_scale(convert, frame->data, frame->linesize, 0, c->height,
 						rgbframe->data, rgbframe->linesize);
 				if (dec_w != c->width || dec_h != c->height) {
@@ -565,8 +521,6 @@
 				f->height(c->height);
 				int64_t vpts = av_frame_get_best_effort_timestamp(frame);
 				if (v_format == VIDEO_FORMAT_MPEG2)
-					vpts += 90000*4/10; /* 400ms */
-				else
 					vpts += 90000*3/10; /* 300ms */
 				f->pts(vpts);
 				AVRational a = av_guess_sample_aspect_ratio(avfc, avfc->streams[0], frame);
@@ -575,7 +529,7 @@
 				buf_in %= VDEC_MAXBUFS;
 				buf_num++;
 				if (buf_num > (VDEC_MAXBUFS - 1)) {
+					lt_debug("%s: buf_num overflow\n", __func__);
-					lt_info("%s: buf_num overflow\n", __func__);
 					buf_out++;
 					buf_out %= VDEC_MAXBUFS;
 					buf_num--;
@@ -586,15 +540,12 @@
 			lt_debug("%s: time_base: %d/%d, ticks: %d rate: %d pts 0x%" PRIx64 "\n", __func__,
 					c->time_base.num, c->time_base.den, c->ticks_per_frame, dec_r,
 					av_frame_get_best_effort_timestamp(frame));
+		}
+		av_free_packet(&avpkt);
-		} else
-			lt_info("%s: got_frame: %d stillpicture: %d\n", __func__, got_frame, stillpicture);
-		still_m.unlock();
-		av_packet_unref(&avpkt);
 	}
 	sws_freeContext(convert);
  out2:
 	avcodec_close(c);
-	av_free(c);
 	av_frame_free(&frame);
 	av_frame_free(&rgbframe);
  out:
@@ -603,59 +554,35 @@
 	av_free(pIOCtx);
 	/* reset output buffers */
 	bufpos = 0;
+	buf_num = 0;
+	buf_in = 0;
+	buf_out = 0;
-	still_m.lock();
-	if (!stillpicture) {
-		buf_num = 0;
-		buf_in = 0;
-		buf_out = 0;
-	}
-	still_m.unlock();
 	lt_info("======================== end decoder thread ================================\n");
 }
 
+static bool swscale(unsigned char *src, unsigned char *dst, int sw, int sh, int dw, int dh)
-static bool swscale(unsigned char *src, unsigned char *dst, int sw, int sh, int dw, int dh, AVPixelFormat sfmt)
 {
 	bool ret = false;
-	int len = 0;
 	struct SwsContext *scale = NULL;
+	AVFrame *sframe, *dframe;
+	scale = sws_getCachedContext(scale, sw, sh, PIX_FMT_RGB32, dw, dh, PIX_FMT_RGB32, SWS_BICUBIC, 0, 0, 0);
-	scale = sws_getCachedContext(scale, sw, sh, sfmt, dw, dh, AV_PIX_FMT_RGB32, SWS_BICUBIC, 0, 0, 0);
 	if (!scale) {
 		lt_info_c("%s: ERROR setting up SWS context\n", __func__);
+		return false;
-		return ret;
 	}
+	sframe = av_frame_alloc();
+	dframe = av_frame_alloc();
+	if (!sframe || !dframe) {
-	AVFrame *sframe = av_frame_alloc();
-	AVFrame *dframe = av_frame_alloc();
-	if (sframe && dframe) {
-		len = av_image_fill_arrays(sframe->data, sframe->linesize, &(src)[0], sfmt, sw, sh, 1);
-		if(len>-1)
-			ret = true;
-
-		if(ret && (len = av_image_fill_arrays(dframe->data, dframe->linesize, &(dst)[0], AV_PIX_FMT_RGB32, dw, dh, 1)<0))
-			ret = false;
-
-		if(ret && (len = sws_scale(scale, sframe->data, sframe->linesize, 0, sh, dframe->data, dframe->linesize)<0))
-			ret = false;
-		else
-			ret = true;
-	}else{
 		lt_info_c("%s: could not alloc sframe (%p) or dframe (%p)\n", __func__, sframe, dframe);
+		goto out;
-		ret = false;
 	}
+	avpicture_fill((AVPicture *)sframe, &(src[0]), PIX_FMT_RGB32, sw, sh);
+	avpicture_fill((AVPicture *)dframe, &(dst[0]), PIX_FMT_RGB32, dw, dh);
+	sws_scale(scale, sframe->data, sframe->linesize, 0, sh, dframe->data, dframe->linesize);
+ out:
+	av_frame_free(&sframe);
+	av_frame_free(&dframe);
+	sws_freeContext(scale);
-
-	if(sframe){
-		av_frame_free(&sframe);
-		sframe = NULL;
-	}
-	if(dframe){
-		av_frame_free(&dframe);
-		dframe = NULL;
-	}
-	if(scale){
-		sws_freeContext(scale);
-		scale = NULL;
-	}
-	lt_info_c("%s: %s scale %ix%i to %ix%i ,len %i\n",ret?" ":"ERROR",__func__, sw, sh, dw, dh,len);
-
 	return ret;
 }
 
@@ -686,40 +613,24 @@
 				xres = vid_w * a.num / a.den;
 		}
 	}
-	if(video.empty()){
-		get_video=false;
-		xres = osd_w;
-		yres = osd_h;
-	}
 	if (get_osd)
 		osd = glfb->getOSDBuffer();
+	unsigned int need = avpicture_get_size(PIX_FMT_RGB32, xres, yres);
-	unsigned int need = av_image_get_buffer_size(AV_PIX_FMT_RGB32, xres, yres, 1);
 	data = (unsigned char *)realloc(data, need); /* will be freed by caller */
 	if (data == NULL)	/* out of memory? */
 		return false;
 
 	if (get_video) {
+		if (vid_w != xres || vid_h != yres) /* scale video into data... */
+			swscale(&video[0], data, vid_w, vid_h, xres, yres);
+		else /* get_video and no fancy scaling needed */
-		//memcpy dont work with copy BGR24 to RGB32
-		if (vid_w != xres || vid_h != yres){ /* scale video into data... */
-			bool ret = swscale(&video[0], data, vid_w, vid_h, xres, yres, AV_PIX_FMT_RGB32);
-			if(!ret){
-				free(data);
-				return false;
-			}
-		//memcpy dont work with copy BGR24 to RGB32
-		} else { /* get_video and no fancy scaling needed */
 			memcpy(data, &video[0], xres * yres * sizeof(uint32_t));
-		}
 	}
 
 	if (get_osd && (osd_w != xres || osd_h != yres)) {
 		/* rescale osd */
 		s_osd.resize(need);
+		swscale(&(*osd)[0], &s_osd[0], osd_w, osd_h, xres, yres);
-		bool ret = swscale(&(*osd)[0], &s_osd[0], osd_w, osd_h, xres, yres,AV_PIX_FMT_RGB32);
-		if(!ret){
-			free(data);
-			return false;
-		}
 		osd = &s_osd;
 	}
 
reverted:
--- b/generic-pc/video_lib.h
+++ a/generic-pc/video_lib.h
@@ -157,8 +157,8 @@
 
 		/* aspect ratio */
 		int getAspectRatio(void);
+		void getPictureInfo(int &width, int &height, int &rate);
 		int setAspectRatio(int aspect, int mode);
-		void getPictureInfo(int &width, int &height, int &rate);
 
 		/* cropping mode */
 		int setCroppingMode(int x = 0 /*vidDispMode_t x = VID_DISPMODE_NORM*/);
@@ -170,22 +170,20 @@
 		int getBlank(void);
 		int setBlank(int enable);
 
-		/* set video_system */
-		int SetVideoSystem(int video_system, bool remember = true);
-		int GetVideoSystem();
-
 		/* change video play state. Parameters are all unused. */
 		int Start(void *PcrChannel = NULL, unsigned short PcrPid = 0, unsigned short VideoPid = 0, void *x = NULL);
 		int Stop(bool blank = true);
 		bool Pause(void);
 
+		/* set video_system */
+		int SetVideoSystem(int video_system, bool remember = true);
+		int GetVideoSystem();
 		int SetStreamType(VIDEO_FORMAT type);
-		void ShowPicture(const char * fname);
-
 		void SetSyncMode(AVSYNC_TYPE mode);
 		bool SetCECMode(VIDEO_HDMI_CEC_MODE) { return true; };
 		void SetCECAutoView(bool) { return; };
 		void SetCECAutoStandby(bool) { return; };
+		void ShowPicture(const char * fname, const char * destname = NULL);
 		void StopPicture();
 		void Standby(unsigned int bOn);
 		void Pig(int x, int y, int w, int h, int osd_w = 1064, int osd_h = 600, int startx = 0, int starty = 0, int endx = 1279, int endy = 719);
@@ -220,9 +218,6 @@
 		int pig_y;
 		int pig_w;
 		int pig_h;
-		bool pig_changed;
-		Mutex still_m;
-		bool stillpicture;
 };
 
 #endif
